<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Image Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c;
            color: white;
        }
        .container {
            width: 100%;
            max-width: 1200px;
            padding: 20px;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        .image-container {
            aspect-ratio: 16/9;
            background-color: #2d3748;
            margin-bottom: 16px;
            position: relative;
            overflow: hidden;
            border-radius: 8px;
        }
        .image-container img, .image-container canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .upload-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #3182ce;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 10;
        }
        .upload-input {
            display: none;
        }
        .button {
            background-color: #3182ce;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        .button:hover {
            background-color: #2c5282;
        }
        .button:disabled {
            background-color: #718096;
            cursor: not-allowed;
        }
        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }
        .gallery-item {
            aspect-ratio: 1;
            background-color: #2d3748;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
        }
        .gallery-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .toolbar {
            display: flex;
            justify-content: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        .tool {
            background-color: #4a5568;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        .tool.active {
            background-color: #3182ce;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #2d3748;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 500px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: #fff;
            text-decoration: none;
            cursor: pointer;
        }
        #errorMessage {
            color: #fc8181;
            margin-top: 10px;
            text-align: center;
        }
        .text-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .text-element {
            position: absolute;
            cursor: move;
            user-select: none;
            padding: 2px;
            border: 1px solid transparent;
        }
        .text-element:hover, .text-element.selected {
            border-color: #3182ce;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="authContainer">
            <button id="loginButton" class="button">Login</button>
            <span id="principalId"></span>
        </div>
        <div class="controls">
            <div>
                <button id="undoButton" class="button" disabled>Undo</button>
                <button id="redoButton" class="button" disabled>Redo</button>
                <button id="resetButton" class="button" disabled>Reset</button>
                <button id="saveButton" class="button" disabled>Save</button>
                <button id="shareButton" class="button" disabled>Share</button>
                <button id="exportButton" class="button" disabled>Export</button>
            </div>
        </div>
        
        <div class="toolbar">
            <button class="tool" data-tool="brush">Brush</button>
            <button class="tool" data-tool="eraser">Eraser</button>
            <button class="tool" data-tool="text">Text</button>
            <button class="tool" data-tool="crop">Crop</button>
            <button class="tool" data-tool="rotate">Rotate</button>
            <button class="tool" data-tool="resize">Resize</button>
            <button class="tool" data-tool="filter">Filters</button>
        </div>
        
        <div class="image-container" id="imageContainer">
            <canvas id="canvas"></canvas>
            <div class="text-overlay" id="textOverlay"></div>
            <label class="upload-label" id="uploadLabel">
                Upload Image
                <input type="file" accept="image/*" class="upload-input" id="imageUpload">
            </label>
        </div>

        <div id="errorMessage"></div>

        <div class="gallery" id="gallery"></div>
    </div>

    <div id="textModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Add Text</h2>
            <input type="text" id="textInput" placeholder="Enter text">
            <input type="color" id="textColor" value="#000000">
            <input type="number" id="textSize" min="10" max="100" value="30">
            <button id="addTextButton" class="button">Add Text</button>
        </div>
    </div>

    <div id="resizeModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Resize Image</h2>
            <input type="number" id="widthInput" placeholder="Width">
            <input type="number" id="heightInput" placeholder="Height">
            <button id="resizeButton" class="button">Resize</button>
        </div>
    </div>

    <div id="filterModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Apply Filter</h2>
            <button class="button" data-filter="grayscale">Grayscale</button>
            <button class="button" data-filter="sepia">Sepia</button>
            <button class="button" data-filter="invert">Invert</button>
        </div>
    </div>

    <script type="module">
        import { AuthClient } from "@dfinity/auth-client";
        import { Actor, HttpAgent } from "@dfinity/agent";

        let authClient;
        let actor;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageUpload = document.getElementById('imageUpload');
        const uploadLabel = document.getElementById('uploadLabel');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const resetButton = document.getElementById('resetButton');
        const saveButton = document.getElementById('saveButton');
        const shareButton = document.getElementById('shareButton');
        const exportButton = document.getElementById('exportButton');
        const gallery = document.getElementById('gallery');
        const loginButton = document.getElementById('loginButton');
        const principalId = document.getElementById('principalId');
        const tools = document.querySelectorAll('.tool');
        const textModal = document.getElementById('textModal');
        const resizeModal = document.getElementById('resizeModal');
        const filterModal = document.getElementById('filterModal');
        const errorMessage = document.getElementById('errorMessage');
        const textOverlay = document.getElementById('textOverlay');

        let currentImage = null;
        let editHistory = [];
        let currentEditIndex = -1;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'brush';
        let textElements = [];
        let isDraggingText = false;
        let selectedTextIndex = -1;

        const backendCanisterIdEnvVar = 'BACKEND_CANISTER_ID';
        const backendCanisterId = process.env[backendCanisterIdEnvVar] || '';

        const idlFactory = ({ IDL }) => {
            return IDL.Service({
                'uploadImage': IDL.Func([IDL.Text, IDL.Vec(IDL.Nat8)], [IDL.Variant({ 'ok' : IDL.Null, 'err' : IDL.Text })], []),
                'getImage': IDL.Func([IDL.Text], [IDL.Variant({ 'ok' : IDL.Vec(IDL.Nat8), 'err' : IDL.Text })], ['query']),
                'listImages': IDL.Func([], [IDL.Vec(IDL.Text)], ['query']),
                'deleteImage': IDL.Func([IDL.Text], [IDL.Variant({ 'ok' : IDL.Null, 'err' : IDL.Text })], [])
            });
        };

        async function initAuth() {
            authClient = await AuthClient.create();
            if (await authClient.isAuthenticated()) {
                handleAuthenticated();
            }
        }

        async function login() {
            try {
                await authClient.login({
                    identityProvider: "https://identity.ic0.app/#authorize",
                    onSuccess: handleAuthenticated,
                });
            } catch (error) {
                console.error("Login failed:", error);
                showError("Login failed. Please try again.");
            }
        }

        async function handleAuthenticated() {
            const identity = await authClient.getIdentity();
            principalId.textContent = identity.getPrincipal().toText();
            loginButton.style.display = 'none';

            const agent = new HttpAgent({ identity });
            actor = Actor.createActor(idlFactory, {
                agent,
                canisterId: backendCanisterId,
            });

            loadGallery();
            enableButtons();
        }

        function enableButtons() {
            saveButton.disabled = false;
            shareButton.disabled = false;
            exportButton.disabled = false;
        }

        loginButton.onclick = login;

        function handleImageUpload(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    currentImage = canvas.toDataURL();
                    saveEditState();
                    uploadLabel.style.display = 'none';
                    enableButtons();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function saveEditState() {
            editHistory = editHistory.slice(0, currentEditIndex + 1);
            editHistory.push({
                imageData: canvas.toDataURL(),
                textElements: JSON.parse(JSON.stringify(textElements))
            });
            currentEditIndex = editHistory.length - 1;
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            undoButton.disabled = currentEditIndex <= 0;
            redoButton.disabled = currentEditIndex >= editHistory.length - 1;
        }

        function undo() {
            if (currentEditIndex > 0) {
                currentEditIndex--;
                loadEditState(editHistory[currentEditIndex]);
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (currentEditIndex < editHistory.length - 1) {
                currentEditIndex++;
                loadEditState(editHistory[currentEditIndex]);
                updateUndoRedoButtons();
            }
        }

        function reset() {
            if (currentImage) {
                loadImageFromDataURL(currentImage);
                textElements = [];
                updateTextOverlay();
                saveEditState();
            }
        }

        function loadEditState(state) {
            loadImageFromDataURL(state.imageData);
            textElements = state.textElements;
            updateTextOverlay();
        }

        function loadImageFromDataURL(dataURL) {
            const img = new Image();
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
            };
            img.src = dataURL;
        }

        function updateTextOverlay() {
            textOverlay.innerHTML = '';
            textElements.forEach((element, index) => {
                const textElement = document.createElement('div');
                textElement.className = 'text-element';
                textElement.style.left = `${element.x}px`;
                textElement.style.top = `${element.y}px`;
                textElement.style.color = element.color;
                textElement.style.fontSize = `${element.size}px`;
                textElement.textContent = element.text;
                textElement.dataset.index = index;
                textElement.addEventListener('mousedown', startDraggingText);
                textOverlay.appendChild(textElement);
            });
        }

        async function saveImage() {
            if (!canvas.toDataURL()) return;
            if (!actor) {
                showError("Please login before saving.");
                return;
            }

            try {
                const blob = await new Promise(resolve => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(canvas, 0, 0);
                    textElements.forEach(element => {
                        tempCtx.font = `${element.size}px Arial`;
                        tempCtx.fillStyle = element.color;
                        tempCtx.fillText(element.text, element.x, element.y);
                    });
                    tempCanvas.toBlob(resolve, 'image/png');
                });
                const arrayBuffer = await blob.arrayBuffer();
                const name = `image_${Date.now()}.png`;

                await actor.uploadImage(name, [...new Uint8Array(arrayBuffer)]);
                showError('Image saved successfully!', false);
                loadGallery();
            } catch (error) {
                console.error('Error saving image:', error);
                showError('Failed to save image. Please try again.');
            }
        }

        async function loadGallery() {
            try {
                const imageNames = await actor.listImages();
                gallery.innerHTML = '';
                for (const name of imageNames) {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(new Blob([await actor.getImage(name)], { type: 'image/png' }));
                    img.alt = name;
                    img.onclick = () => loadImageFromGallery(name);
                    const galleryItem = document.createElement('div');
                    galleryItem.className = 'gallery-item';
                    galleryItem.appendChild(img);
                    gallery.appendChild(galleryItem);
                }
            } catch (error) {
                console.error('Error loading gallery:', error);
                showError('Failed to load gallery. Please try again.');
            }
        }

        async function loadImageFromGallery(name) {
            try {
                const imageBlob = await actor.getImage(name);
                const img = new Image();
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    currentImage = canvas.toDataURL();
                    textElements = [];
                    updateTextOverlay();
                    saveEditState();
                    uploadLabel.style.display = 'none';
                    enableButtons();
                };
                img.src = URL.createObjectURL(new Blob([imageBlob], { type: 'image/png' }));
            } catch (error) {
                console.error('Error loading image from gallery:', error);
                showError('Failed to load image. Please try again.');
            }
        }

        function shareImage() {
            if (!canvas.toDataURL()) return;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            textElements.forEach(element => {
                tempCtx.font = `${element.size}px Arial`;
                tempCtx.fillStyle = element.color;
                tempCtx.fillText(element.text, element.x, element.y);
            });
            tempCanvas.toBlob(blob => {
                const file = new File([blob], "edited_image.png", { type: "image/png" });
                const shareData = {
                    files: [file],
                };
                if (navigator.share && navigator.canShare(shareData)) {
                    navigator.share(shareData)
                        .then(() => console.log('Image shared successfully'))
                        .catch((error) => {
                            if (error.name !== 'AbortError') {
                                console.error('Error sharing image:', error);
                                showError('Failed to share image. Please try again.');
                            }
                        });
                } else {
                    showError('Sharing is not supported on this device/browser');
                }
            }, 'image/png');
        }

        function exportImage() {
            if (!canvas.toDataURL()) return;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            textElements.forEach(element => {
                tempCtx.font = `${element.size}px Arial`;
                tempCtx.fillStyle = element.color;
                tempCtx.fillText(element.text, element.x, element.y);
            });
            const link = document.createElement('a');
            link.download = 'edited_image.png';
            link.href = tempCanvas.toDataURL();
            link.click();
        }

        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function draw(e) {
            if (!isDrawing) return;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function stopDrawing() {
            isDrawing = false;
            saveEditState();
        }

        function setActiveTool(tool) {
            currentTool = tool;
            tools.forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');

            switch(tool) {
                case 'brush':
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 5;
                    break;
                case 'eraser':
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = 20;
                    break;
                case 'text':
                    textModal.style.display = 'block';
                    break;
                case 'crop':
                    // Implement crop functionality
                    break;
                case 'rotate':
                    rotateImage();
                    break;
                case 'resize':
                    resizeModal.style.display = 'block';
                    break;
                case 'filter':
                    filterModal.style.display = 'block';
                    break;
            }
        }

        function addText() {
            const text = document.getElementById('textInput').value;
            const color = document.getElementById('textColor').value;
            const size = parseInt(document.getElementById('textSize').value);
            if (text) {
                textElements.push({
                    text,
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    color,
                    size
                });
                updateTextOverlay();
                saveEditState();
            }
            textModal.style.display = 'none';
        }

        function rotateImage() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.height;
            tempCanvas.height = canvas.width;
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate(Math.PI / 2);
            tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.width = tempCanvas.width;
            canvas.height = tempCanvas.height;
            ctx.drawImage(tempCanvas, 0, 0);
            saveEditState();
        }

        function resizeImage() {
            const width = parseInt(document.getElementById('widthInput').value);
            const height = parseInt(document.getElementById('heightInput').value);
            if (width && height) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = width;
                tempCanvas.height = height;
                tempCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, width, height);
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(tempCanvas, 0, 0);
                saveEditState();
            }
            resizeModal.style.display = 'none';
        }

        function applyFilter(filter) {
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            switch(filter) {
                case 'grayscale':
                    for (let i = 0; i < data.length; i += 4) {
                        let avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = data[i + 1] = data[i + 2] = avg;
                    }
                    break;
                case 'sepia':
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i], g = data[i + 1], b = data[i + 2];
                        data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                        data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                        data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                    }
                    break;
                case 'invert':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = 255 - data[i];
                        data[i + 1] = 255 - data[i + 1];
                        data[i + 2] = 255 - data[i + 2];
                    }
                    break;
            }
            ctx.putImageData(imageData, 0, 0);
            saveEditState();
            filterModal.style.display = 'none';
        }

        function showError(message, isError = true) {
            errorMessage.textContent = message;
            errorMessage.style.color = isError ? '#fc8181' : '#68d391';
            setTimeout(() => {
                errorMessage.textContent = '';
            }, 3000);
        }

        function startDraggingText(e) {
            isDraggingText = true;
            selectedTextIndex = parseInt(e.target.dataset.index);
            lastX = e.clientX;
            lastY = e.clientY;
            document.addEventListener('mousemove', dragText);
            document.addEventListener('mouseup', stopDraggingText);
        }

        function dragText(e) {
            if (!isDraggingText) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            
            textElements[selectedTextIndex].x += dx;
            textElements[selectedTextIndex].y += dy;
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            updateTextOverlay();
        }

        function stopDraggingText() {
            if (isDraggingText) {
                isDraggingText = false;
                saveEditState();
                document.removeEventListener('mousemove', dragText);
                document.removeEventListener('mouseup', stopDraggingText);
            }
        }

        imageUpload.addEventListener('change', handleImageUpload);
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);
        resetButton.addEventListener('click', reset);
        saveButton.addEventListener('click', saveImage);
        shareButton.addEventListener('click', shareImage);
        exportButton.addEventListener('click', exportImage);
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        tools.forEach(tool => tool.addEventListener('click', () => setActiveTool(tool.dataset.tool)));
        document.getElementById('addTextButton').addEventListener('click', addText);
        document.getElementById('resizeButton').addEventListener('click', resizeImage);
        document.querySelectorAll('#filterModal .button').forEach(btn => {
            btn.addEventListener('click', () => applyFilter(btn.dataset.filter));
        });
        document.querySelectorAll('.close').forEach(closeBtn => {
            closeBtn.addEventListener('click', () => closeBtn.closest('.modal').style.display = 'none');
        });

        initAuth();
    </script>
</body>
</html>
